<!--
 * Author       : ajin
 * Date         : 2020-03-27 11:28:40
 * Description  : 
 * email        : ajin_w@163.com
 * 那曾梦想屠龙的少年，终会变成油腻的中年大叔，端坐于显示器前，从指尖流淌的代码，终会改变整个世界
 -->


从词法分析角度来看, 语言是一个单词的集合, 称之为正规集, 单词是由一个个字符组成的线性结构, 从语法分析角度来看, 语言是一个句子的集合, 而句子是由词法分析器返回的记号组成的非线性结构, 反映句子结构最好的方法是树

词法分析具有双重含义: 

1. 规定句子形成的规则, 也称为语法规则, 程序设计语言大部分语法规则可以用上下文无关文法(context free grammar, CFG)来描述
2. 根据语法规则识别记号流中的语言结构, 也称为语法分析

## 语法分析中的问题
### 语法分析器的作用
前端的中心部件是语法分析器, 主要作用:

1. 根据词法分析提供的记号流, 为语法正确的输入构造分析树
2. 检查输入中的语法(也包括词法)错误, 并调用出错处理器进行适当处理

### 语法错误的处理原则
1. 源程序可能出现的错误分为两类, 语法错误和语义错误, 语法错误又包括词法错误和语法错误, 词法错误值出现非法字符或关键字,标识符拼写错误等, 语法错误是指语法结构出错, 结构匹配问题等. 语义错误包括静态语义错误和动态语义错误, 静态语义错误涉及的是编译时可检查出来的错误, 如类型不一致, 参数匹配等, 动态语义错误一般是值程序运行时的逻辑错误等

2. 语法错误处理的目标
    1. 清楚准确的报告错误的出现, 地点正确, 不漏报, 不错报, 不多报
    2. 迅速恢复错误
    3. 对语法正确源程序分析速度不应该降低太多

3. 语法错误的恢复策略
    1. 紧急方式恢复, 发现错误,分析器抛弃输入记号, 向前搜索到指定合法记号集合为止
    2. 短语级恢复: 发现错误时, 分析器采用串替换的方式对剩余输入进行局部纠正, 他用可以使分析器继续的输入串来代替剩余输入的前缀
    3. 出错产生式: 预测被分析语言可能出现的错误, 用出错产生式来捕捉错误
    4. 全局纠正: 对有语法错误的输入序列, 根据文法G构造相近的序列y的语法树, 使得x变换成y所需的修改次数最小


## 上下文无关文法
### 上下文无关文法的定义与表示
是由一个四元组 G = (N, T, P, S)
1. N是非终结符的有限集合
2. T是终结符的有限集合, 且 N n T = 空集
3. P是产生式的有限集合
4. S是非终结符, 称为文法的开始符号

### CFG产生语言的基本方法--推导
1. 将产生式 A -> y 的右部代替文法符号序列 aAb 中的A得到 ayb的过程称为aAb直接推导出 ayb, * 零步推导和多步推导,至少一步推导, 即为+, 人和我文法符号序列 都可以推导出它自身, 推导具有传递性

2. 在推导过程中, 若每次直接推导均替换句型中最左边的非终结符, 则称为最左推导, 由最左推导产生的句型也称为左句型

### 推导, 分析树, 语法树
1. 对于CFG G的句型, 分析树定定义为具有以下性质的树
    1. 根由开始符号所标记
    2. 每个叶子由一个终结符, 非终结符或e标记
    3. 每个内部结点由一个非终结符标记

分析树与文法和语言存在关系: 每一直接推导(或者每个产生式)对应一颗仅有父子关系的子树, 即产生式左部非终结符"长出"右部的孩子, 分析树的叶子从左到右构成G的一个句型, 若叶子仅有终结符标记, 则构成一个句子

2. 对于CFG G的句型, 表达式的语法树被定义为具有一下性质的树
    1. 根与内部结点有表达式的操作符标记
    2. 叶子由表达式中的操作数标记
    3. 用于改变运算优先级和结合性的括弧被隐含在语法树的结构中


### 二义性和二义性的消除
若文法G对于同一个句子产生不止一颗分析树, 则称G是二义的, 文法二义的本质是在产生句子的过程中某些直接推导有多余一种选择, 从而使得下一步分析不确定

二义性的消除

二义文法不是CFG, 如果一个文法是二义的, 并不意味这他说产生的语言一定是二义的, 只有当产生一个语言的所有文法都是二义的时, 这个语言才被认为是一定是二义的.

1. 改写二义文法为非二义文法
2. 对二义文法添加限制, 具体为文法符号定义优先级和结合性, 使得分析中只能产生一颗分析树

结论

1. 由于新引入的非终结符限制每一步直接推导均有唯一选择, 使得同一个句子仅有一个分析树
2. 最终产生的分析树与推导方法无关, 而仅与文法的描述有关
3. 引入新的非终结符, 推导步骤增加
4. 越接近S的A与a, 优先级越低


## 语言与文法简介
程序设计语言结构均可以用文法描述

1. 文法给出了精确地易于理解的语言结构说明
2. 以文法为基础的语言, 便于加入新的或修改, 删除旧的语言结构
3. 有些类别的文法, 自已自动生成高效的分析器

为什么用正规式而不用CFG描述程序设计的词法

1. 词法规则简单, 用正规式描述足够了
2. 正规式的表示比CFG更直观, 简洁, 易于理解
3. 有限自动机的构造比下推自动机简单, 且分析效率高
4. 区分词法和语法, 为编译前端模块划分提供方便

正规式适合描述线性结构，如标识符、关键字、注释等。而CFG适合描述具有嵌套(层次)性质的非线性结构，如不同结构的句子if-then-else、begin-end等。 


### 上下文有关文法CSG
CFG无法描述的所谓上下文无关结构: 变量的声明和引用, 过程调用时形参和实参的一致性检查


### 形式语言和自动机简介
若文法G= (N, T, P, S)的每个产生式a -> b中, 均有a属于(N U T)*, 则至少含有一个非终结符, b属于(B U T)\*, 则称G为0型文法

对0型文法加上一下第i条限制, 即可得到第i型文法
1. G的任何产生式a -> b(S -> e除外), 均满足|a| <= |b|(|x|表示x中文法符号的个数)
2. G的任何产生式形如A - b, 其中A属于N, b属于(N U T)*
3. G的任何产生式形如A -> a, 或者A -> aB(或者 A -> Ba), 其中A, B属于N, a属于T

## 自上而下语法分析
自上而下分析的基本思想是: 对于任何一个输入序列, 从文法的开始符号开始, 进行最左推导, 直到得带一个合法句子或发现一个合法结构

分析使用试探加回溯的方法会存在问题

1. 若存在形如A -> ab1|ab2的产生式, 有公共左因子, 则可能会造成虚假匹配, 产生大量回溯
2. 若存在 A -> Aa的产生式, 则分析过程中一旦采用了该产生式去替换, 可能会造成左递归

### 消除左递归
若文法G中的非终结符A, 对某个文法符号序列a存在至少一次推导A => Aa, 则称文法G是左递归的, 若文法G中有形如A -> Aa的产生式, 则称该产生式对A直接左递归

可以用非左递归的A -> bA'和A' -> aA'|e取代
L  → E ；L | ε

E  → T E'

E' → + T E' | – T E' | ε 
    
T  → F T' 

T' → * F T' | / F T' |  mod F T' | ε

F  → ( E )| id | num 


### 提取左因子
对于有左因子的文法, 推导过程中会出现无法确定用A产生式的哪个候选项替换A的情况, 这时可以重写A产生式来推迟这种决定, 直到看见足够的输入, 能正确选择为止


当一个文法中既有左递归又含左因子时，一般的做法是先消除左递归。因为左递归也是左因子的一种形式，当左递归消除后，同时也消除了部分左因子

![流程图](https://s1.ax1x.com/2020/04/10/GoH2x1.jpg)

### 递归下降分析
递归下降分析是直接以程序的方式模拟产生式产生语言的过程。它的基本思想是：为每一个非终结符构造一个子程序，每一个子程序的过程体中按该产生式的候选项分情况展开，遇到终结符直接匹配，而遇到非终结符就调用相应非终结符的子程序。该分析从调用文法开始符号的子程序开始，直到所有非终结符都展开为终结符并得到匹配为止


### 预测分析器

预测分析器由一张预测分析表、一个符号栈和一个驱动器组成。它把程序模拟的状态转换变成分析表中的内容，用分析表指导驱动器完成对输入序列的分析。由于消除了递归子程序调用，所以也称为非递归预测分析器或者表驱动的预测分析器，它的数学模型是下推自动机。

## 非递归预测分析器工作模式
1. 下推自动机与格局
它是由一个只读头, 一个下推栈和一个有限状态转移组成, 预测分析器是下推自动机的一个具体实现, 下推栈是一个符号栈, 其中存放终结符和非终结符, 他的有限状态转移控制由一个预测分析表和一个驱动器组成

![图示](https://s1.ax1x.com/2020/04/10/GoO70P.png)

下推自动机的工作模式是一种放幻灯的方式，此处的每张“幻灯片”称为一个格局.格局是个三元组：(栈内容，当前剩余输入(简称剩余输入)，改变格局的动作)。分析是从某个初始格局开始的，经过一系列的格局变化，最终到达接收格局，表明分析成功；或者到达出错格局，表明发现一个语法错误

预测分析器中，驱动器与预测分析表协同工作，实现对格局的改变。驱动器根据当前输入和栈顶内容，查表确定改变格局的动作。预测分析表是一个二维数组M[A, a]，所有的非终结符构成分析表的行下标，所有的终结符构成分析表的列下标，其中包括特殊的结束标志#。M[A, a]中的内容表示当前栈顶为非终结符A且当前输入为终结符a时，分析器要进行的动作。


构造预测分析表

构造分析表的过程可以分为两步走：首先根据文法构造两个集合，FIRST集合与FOLLOW集合；


每个M[A, a]中最多有一个条目，因此对于每个栈顶符号和当前输入终结符对，有且仅有一个动作与之匹配(包括出错条目)，从而分析的每一步均是确定的。  一个文法G被称为是LL(1)文法，当且仅当为它构造的预测分析表中不含多重定义的条目。由此分析表所组成的分析器被称为LL(1)分析器，它所分析的语言被称为LL(1)语言。

## 文法的扩展BNF(EBNF)
与正规式的简化表示类似，为了书写和表达的简洁方便，可以对产生式集进行扩充，称为文法的扩展BNF表示,具体可以在产生式的右部引入下述符号进行扩充，每种扩充形式均可以与程序的某种语句结构直接对应

{  }：被括在{ }中的内容可以重复0或若干次

[  ]：被括在[ ]中的内容是可选择的

|：“|”在BNF表示中代表产生式中各候选项的或关系

(  )：利用( )可以改变运算的优先级和结合性


 
在预测分析模式中，有四种改变格局的动作。匹配终结符,展开非终结符,报告分析成功,报告出错



(1) 若X是终结符，则FIRST(X)={X}；
(2) 若X 是非终结符且有X→ε，则加入ε到FIRST(X)；
(3) 若X 是非终结符且有X→Y1Y2...Yk，并令Y0=ε，Yk+1=ε，则对所有j(0≤j≤k)，若a∈FIRST(Yj+1)且ε∈FIRST(Yj)，加入a到FIRST(X)。 


一个文法G被称为是LL(1)文法，当且仅当为它构造的预测分析表中不含多重定义的条目。由此分析表所组成的分析器被称为LL(1)分析器

1．规范归约与“剪句柄”
定义3.13  设αβδ是文法G的一个句型，若存在SαAδ，Aβ，则称β是句型αβδ相对于A的短语。特别的，若有A→β，则称β是句型αβδ相对于产生式A→β的直接短语。一个句型的最左直接短语被称为句柄。

 分析树中的叶子与短语、直接短语和句柄有下述关系。
(1) 短语：以非终结符为根的子树中所有从左到右排列的叶子；
(2) 直接短语：只有父子关系的树中所有从左到右排列的叶子(树高为2)；
(3) 句柄：最左边父子关系树中所有从左到右排列的叶子(句柄是唯一的)。 


若在语法分析器中实现剪句柄，则有两个问题必须解决：
(1) 确定右句型中将要归约的子串(确定句柄)；
(2) 确定如何选择正确的产生式进行归约。


 在移进—归约分析模式中，改变格局变化的动作有以下四种形式。
① 移进(shift):  把当前输入中的下一个终结符移进栈；
② 归约(reduce): 句柄在栈顶已形成，用适当产生式左部代替句柄；
③ 接受(accept): 宣告分析成功；
④ 报错(error):  发现语法错误，调用错误恢复例程。


(1)句柄总是在栈顶形成。这是因为在分析的过程中一旦形成某产生式的右部，就立即进行归约，从左到右扫描输入，最早形成的自然是最左的直接短语。
(2) 栈中保留的总是一个右句型的前缀，也称为活前缀。
(3) 如果在逻辑上将每次归约认为是构造对应产生式的树，则分析的全过程逻辑上就是从下到上构造一棵分析树；反之，如果在逻辑上将每次归约认为是剪去假想分析树上对应产生式的孩子，则分析的全过程逻辑上就是从下到上为分析树剪句柄。



LR分析是应用最广泛的一类分析方法，它是实用的编译器中功能最强的分析器，其特点是：
(1) 采用最一般的无回溯移进—归约方法；
(2) 可分析的文法是LL文法的真超集；
(3) 能够及时发现错误，快到从左到右扫描输入序列的最大可能；
(4) 分析表较复杂，难以手工构造。 


活前缀首先是一个右句型的前缀，并且它一定是已在栈中的内容。因此，在活前缀右边加上若干(可以是0)个终结符，即可得到一个右句型。而在移进—归约分析中，只要保证已扫描过的输入序列可以归约为一个活前缀，就意味着分析到目前为止没有错误。LR分析的基本思想就是为文法G构造一个识别它的所有活前缀的DFA。由于右句型也可以是一个活前缀，识别活前缀的DFA实质上就是识别G所产生语言的DFA。 


一个LR(0)项目(简称项目)是这样一个产生式，在它右部的某个位置上，有一个点“.”。对于A→ε，它仅有一个项目A→.。 
一个产生式右部若有n个文法符号，则该产生式有n+1个LR(0)项目


项目中的点把产生式右部分成两个部分：A→α.β，它表示在分析的过程中看到了产生式右部的多少内容。当β不为空时，表示产生式右部还没有全部看到，需要继续移进；而一旦β为空，表示当前栈顶已经形成一个句柄，可以进行归约。因此，β不为空的项目称为可移进项目，β为空的项目称为可归约项目


文法的每个产生式可以看作是一个识别活前缀的NFA，而项目就是NFA中的一个状态

词法分析中“子集法”构造的两个主要过程：　
(1) ε_闭包(I)：求出在I状态集下，不经任何字符a所能到达状态的全体；
(2) smove(I，a)：求出在I中，所有经字符a状态转移所能直接到达的状态全体。


对所有属于项目集I、且形如[A→α.Xβ]的项目，令X∈N∪T，则goto(I，X)是所有形如[A→αX.β]的项目。


项目[S'→.S]和所有“.”不在产生式右部最左边的项目称为核心项目(kernel items)，其他所有“.”在产生式右部最左边的项目(不包括[S'→.S])称为非核心项目(nonkernel items)。  


识别活前缀的DFA的一个状态，是NFA的一个状态集合，称为LR(0)项目集，DFA的所有状态被称为LR(0)项目集族

若存在最右推导S‘αAω=>αβ1β2ω，则项目[A→β1.β2]被称为对活前缀αβ1有效。


当一个项目集中出现下述情况之一，就会出现所谓的冲突。
(1) 一个项目集中既有可移进项目A→β1.β2，又有可归约项目B→β.。这表明下一步既可以移进，又可以归约，从而使得分析无法进行，称为移进/归约冲突。
(2) 一个项目集中有多于一个可归约项目，如既有A→α.又有B→β.。两个可归约项目均可以指导下一步分析，所以引起归约/归约冲突。

解决冲突的简单方法：SLR(1)方法。LR(0)项目集中的冲突，可以采用简单向前看一个终结符的方法来解决。

设计与实现词法分析器的一般步骤：正规式→NFA→DFA→最少状态DFA→词法分析器，或者正规式→语法树→DFA→最少状态DFA→词法分析器