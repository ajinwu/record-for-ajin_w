# 第一章
## 软件危机

软件危机是指计算机软件的开发和维护过程中遇到的一系列严重问题
1. 对软件开发成本和进度的估计常常很不准确
2. 用户对已完成的软件系统不满意的现象经常发生
3. 软件产品的质量不佳
4. 软件常常是不可维护的
5. 软件通常没有适当的文档资料
6. 软件成本在计算机系统总成本所占的比例逐年升高
7. 软件开发生产率提高的速度远远跟不上计算机应用迅速普及深入的趋势

程序测试需要的工作量通常占软件开发的40-50, 软件开发编写程序只占软件开发全部工作量的10-20

一个软件产品必须由一个完整的配置组成, 软件配置主要包括程序, 文档和数据等成分

软件工程是从管理和技术两方面研究如何更好的开发和维护计算机软件的一门新兴学科

软件工程是指导计算机软件开发和维护的一门工程学科

软件工程是1: 把系统的,规范的, 可度量的途径应用与软件开发, 运行和维护过程, 也就是把工程应用于软件

软件工程方法学包含三个要素:方法, 工具和过程

## 软件生命周期
软件生命周期由软件定义, 软件开发和运行维护3个时期组成
1. 问题定义:要解决什么问题
2. 可行性研究: 项目是否值得继续研究
3. 需求分析: 确定系统的功能目标
4. 总体设计: 概括描述如何解决问题
5. 详细设计: 具体描述系统的实现过程
6. 编码和单元测试: 获取正确的程序模块
7. 综合测试: 通过测试
8. 软件维护: 通过各种必要的

## 软件过程
软件过程是为了获得高质量软件所需要完成的一系列任务的框架, 它规定了各项任务的工作步骤

1. 瀑布模型
   1. 阶段间具有顺序性和依赖性, 必须等待前一段时间工作完成以后才能开始下一段时间的工作, 前一段输出文档就是后一段输入文档, 因此只有保证前一阶段输出正确, 后一阶段才能获得正确结果
   2. 推迟实现的观点, 程序的物理实现相对较早反而所需的工作时间也越长
   3. 质量保证的观点, 软件工程的基本目标是优质高产, 应保证两个做法,1:每个阶段必须完成规定的文档, 没有给出合格的文档就是没有完成阶段任务,2:每个阶段结束前都要对所完成的文档进行评审
2. 快速原型模型
   1. 第一步是快速建立一个能反映用户主需求的原型系统, 通过实践来了解目标系统的概貌, 开发人员按照用户的意见快速修改原型系统
   2. 原型系统已经通过与用户交互得到验证, 不会因规格说明错误进行返工
   3. 开发人员建立原型系统已经学到了许多东西, 因此再设计和编码阶段发生错误的可能性较小
3. 增量模型
   1. 目标是一次就把一个满足所有需求的产品提交给客户
   2. 能在较短时间内向用户提交可完成部分工作的产品
   3. 逐步增加产品功能可以使用户有充裕的时间来学习和适应新产品
4. 螺旋模型
   1. 使用原型及其他方法来尽量降低风险, 是吧他看做在每个阶段之前都增加了风险分析过程的快速原型模型
   2. 对可选方案和约束条件的强调有利于已有软件的重用,风险驱动
5. 喷泉模型
   1. 是用户需求为东西, 对象驱动的模型, 各个阶段没有明显的界限
   2. 开发人员可以同时开发, 节省时间, 但需要大量开发人员

RUP软件开发生命周期
1. 初始阶段: 建立业务模型, 定义最终产品视图, 并且确定项目范围
2. 精化阶段: 设计并确定系统体系结构, 指定项目计划, 确定资源需求
3. 构建阶段: 开发出来的所有构建和应用程序, 把他们集成为客户需要的产品, 并且详尽测试功能
4. 移交阶段: 将开发出来的产品提交给用户使用

## 敏捷开发和极限编程
敏捷过程:客户和价值为驱动的模型, 团队成员的合作, 沟通以及交互能力要比单纯的软件编程能力更重要
1. 个体和交互胜过过程和工具
2. 可以工作的软件胜过面面俱到的文档
3. 客户合作胜过合同谈判
4. 响应变化胜过遵循计划

极限编程


# 第二章
数据流图

## 数据字典
数据字典是关于数据的信息的集合, 也就是对数据流图中包含的所有元素的定义的集合, 是在软件分析和设计过程中给人提供关于数据的描述信息

数据流图和数据字典共同构成系统的逻辑模型

组成:数据流, 数据流分量(数据元素), 数据存储, 处理

记录数据元素的信息: 一般信息(名字别名,描述等), 定义(数据类型, 长度, 结构), 使用特点(值得范围, 使用频率, 使用方式), 控制信息(来源, 用户, 改变权),和分组信息(父结构, 从属结构)

数据元素组成数据的方法只有三种基本类型
1. 顺序 确定次序连接两个或多个分量
2. 选择 从两个或多个中选择
3. 重复 把指定的分量重复
4. 可选 分量可有可恶

## 成本估计
1. 代码行技术
2. 任务分解技术, 单项任务成本=任务所需人力*每人每月工资
3. 自动估计

货币时间价值

存入P元, 可得到的钱为 F=P(1+i)^n

如果n年后能收入F元, 那么现在这些钱的价值为P = F/(1+i)^n

投资回收率计算P=F1/(1+j)

# 第三章
实体联系图, 为了把用户的数据要求清楚,准确的描述出来, 系统分析员通常建立一个概念性的数据模型

数据规范化, 为了减少数据冗余, 避免插入异常或删除异常, 简化修改数据的过程, 通常需要把数据结构规范化

状态转换图, 一张状态图只能有一个初态, 终态可以有0个或者多个

层次方框图, 用树形结构的一系列多层次矩形框描述数据的层次结构, 树形结构的顶层是一个单独的矩形框, 代表了完整的数据结构, 下面的各层矩形框代表了这个数据的子集, 最底层的各个框代表了组成这个数据的实际元素(不可再被分割)

Warnier图

IPO图, 是输入处理,输出图的简称

# 第五章
## 设计原理
1. 模块化就是把程序划分成独立命名且可独立访问的模块, 每个模块完成一个子功能, 把这些模块继承起来构成一个整体, 可以完成指定的功能满足用户的需求

2. 抽象, 忽略细节, 分层理解问题, 自顶向下层层递进, 就是抽出事物的本质特性二暂时不考虑他们的细节
3. 逐步求精, 解决复杂问题采用的基本方法
4. 信息隐藏和局部化
5. 模块独立, 是模块,抽象,信息隐藏和局部化概念的直接结果, 定性标准度量, 内聚和耦合
   1. 耦合是不同模块之间互连程序的度量, 耦合强弱取决于模块间接口的复杂程度, 如果两个模块通过参数交换信息, 交换的信息仅仅是数据, 称为数据耦合
   2. 控制耦合, 数据耦合是低耦合
   3. 当整个数据结构作为参数传递而被调用的模块只需要使用一部分数据是, 就出现了特征耦合
   4. 当两个或多个模块通过一个公共数据环境互相作用时, 他们之间的耦合称为公共环境耦合
   5. 最高程度的耦合是内容耦合, 特征: 1. 一个模块访问另一个模块的内部数据 2. 一个模块不通过正常入口转到另一个模块的内部 3. 两个模块共有一部分程序代码重叠 4, 一个模块有多个入口

内聚, 标志着一个模块内各个元素彼此结合的紧密程度
1. 一个模块完成一组任务, 这些任务彼此间即使有关系, 也是很松散的, 叫做偶然内聚
2. 一个模块完成的任务在逻辑上属于相同或相似的一类称为逻辑内聚
3. 一个模块包含的任务必须在同一时间段内执行叫做时间内聚
4. 一个模块的处理元素是相关的, 必须以特定次序执行称为过程内聚
5. 模块内的所有元素都使用同一个输出数据称为通信内聚
6. 一个模块内的处理元素和同一个功能紧密相关, 而且这些处理必须顺序执行称为顺序内聚
7. 功能内聚是最高程度的内聚

启发规则

1. 改进软件结构提高模块独立性
2. 模块规模应该适中
3. 深度,宽度扇出和扇入都应当适当
4. 模块的作用域应该在控制域之内
5. 力争降低模块接口的复杂程度

## 描绘软件结构的图形化工具
层次图和HIPO图

层次图用来描绘软件的层次结构, 一个矩形框代表一个模块, 方框间的连线表示调用关系

结构图

面向数据流的设计方法

1. 交换流, 根据基本系统模型, 信息通常以外部世界的形式进入软件系统, 经过处理以后在以外部世界的形式离开系统
2. 事物流

# 第六章详细设计
程序流程图, 又称程序框图

盒图

PAD图

判定表

判定树

过程设计语言

Jackson图

## 程序复杂程度的定量度量
McCabe方法, 根据程序控制流的复杂程度定量度量程序的复杂程度, 这样度量出的结果称为程序的环形复杂度


软件测试准则
1. 所有测试都应该能追溯到用户
2. 应该远在测试开始之前就指定出测试计划
3. 把Pareto原理应用到软件测试中
4. 应该从小规模测试开始, 并逐步进行大规模测试
5. 穷举测试是不可能的
6. 为了达到最佳的测试效果, 应该有独立的第三方从事测试工作



alpha测试和beta测试

alpha测试由用户在开发者的场所进行, 并且对用户的指导下进行测试

beta测试有软件的最终用户在一个或多个客户场所进行


基本路径测试

黑盒测试技术(功能测试, 数据驱动测试)

等价划分法
1. 如果规定了输入值的范围, 则可划分出一个有效的等价类,两个无效的等价类
2. 如果规定了输入数据的个数, 也可以划分出一个有效的等价类和两个无效的等价类
3. 如果规定了输入数据的一组值, 而且程序对不同输入值做不同处理, 则每个允许输入值是一个有效的等价类, 此外由一个无效的等价类


边界值分析


调试途径
1. print蛮干法
2. 回溯法
3. 原因排除发


# 第八章维护
软件的可维护性
1. 可理解性
2. 可测试性
3. 可修改性
4. 可移植性
5. 可重用性
   
软件再工程过程
1. 库存目录分析
2. 文档重构
3. 逆向工程
4. 代码重构
5. 数据重构
6. 正向工程

# 第九章面向对象方法学
1. 类
2. 实例
3. 消息
4. 方法
5. 属性
6. 封装
7. 继承
8. 多态
9. 重载

用面向对象方法开发软件通常需要建立三种形式的模型
1. 描述系统数据结构的对象模型
2. 描述系统控制结构的动态模型
3. 描述系统功能的功能模型

类图的基本符号,[类名,属性, 服务]

用例建模
1. 寻找行为者
2. 寻找用例

# 第十章
1. 3个子模型与5个层次, 三个要素集静态结构(对象模型), 交互次序(动态模型)和数据变换(功能模型)
2. 对象模型通常由下面五个层次组成, 主题层, 类与对象层, 结构层, 属性层和服务层

建立动态模型

# 第十一章
面向对象设计的准则
1. 模块化
2. 抽象
3. 信息隐藏
4. 弱耦合
   1. 交互耦合, 如果对象之间的耦合通过消息连接来实现, 则这种耦合就是交互耦合
   2. 继承耦合, 继承是一般化类与特殊类之间耦合的一种形式, 通过继承关系结合起来的基类基类和派生类构成了系统中粒度更大的模块, 结合越紧密越好
5. 强内聚
   1. 服务内聚, 一个服务应该完成一个且仅完成一个功能
   2. 类内聚, 设计类的原则是一个类应该只有一个用途
   3. 一般特殊内聚, 设计的一般特殊结构应该符合多数人的概念

启发规则
1. 设计结果应该清晰易懂
2. 一般特殊结构的深度应该适当
3. 设计简单的类
4. 使用简单的协议
5. 使用简单的服务
6. 把设计变动减至最小

# 第十二章
面向对象语言
1. 将来能够占主导地位
2. 可重用性
3. 类库和开发环境
4. 其他因素

提高健壮性, 健壮性是在硬件故障,输入数据无效或操作错误等以外环境下系统能做出适当的响应的程度
1. 预防用户的操作错误
2. 检查参数的合法性
3. 不要预先确定限制条件
4. 先测试后优化

# 第十三章软件项目管理
1. 代码行技术, 计算方式L=(最高+4个中等+最低)/6

Gantt图是制定进度计划的工具
缺点:不能显式描绘各项作业彼此间的依赖关系, 进度计划的关键部分不明确, 难于判定哪些部分应当是主攻和主控的对象,计划中的有潜力的部分及潜力的大小不明确, 往往造成潜力的浪费


工程网络

人员组织
1. 民主制程序员组, 小组成员完全平等,享有充分民主, 通过协商做出技术决策
2. 主程序员组, 软件开发人员多数缺乏经验, 程序设计过程中有许多事务性工作, 多渠道通信很废时间, 将降低程序员的生产率
3. 现代程序员组, 主程序员由两人担任,一个技术负责人负责技术活动,一个行政负责人负责所有非技术事务的管理决策

质量保证
软件质量, 是软件与明确性的和隐含的定义需求相一致的程度

软件配置管理过程
软件配置项
1. 计算机程序(源代码和可执行程序)
2. 描述计算机程序的文档(供技术人员或用户使用)
3. 数据(程序内包含的或在程序外的)

配置过程
1. 标识软件配置中的对象
2. 版本控制
3. 变化控制
4. 配置审计
5. 状态报告

能力成熟度模型CMM
为大型软件项目的招标活动提供一种全面二客观的评审一句
